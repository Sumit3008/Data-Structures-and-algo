/*
	Total no of Simple paths : cover vertices(not a cycle) 
	using (DP + Bitmask)
	Complexity = O(2^n * n^2) time, memory = O(2^n * n)
	
	Source : http://codeforces.com/blog/entry/337
	
	Notation : 
			1) bit(i, mask) - the ith bit of the mask
			2) count(mask) - no of nonzero bits in the mask (__builtin_popcount(mask))
			3) dp[mask][i] - total no of paths(walk) generated by vertices in mask that ends at i.
*/
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>

#define INF 1e9
#define MAXX 20
#define SUBSETS 1100000		//2^20 = 1048575 

using namespace std;

int dp[SUBSETS][MAXX], n, m, d[MAXX+5][MAXX+5];

int bit(int idx, int mask){
	int bit = 0;
	for(int i=0;i<=idx;i++) bit = mask & 1, mask=mask >> 1;
return bit;
}

int poww(int a, int b){
	if(b==0) return 1;if(b==1) return a;
	if(b%2==0){ return poww(a*a, b/2); }
	return a*poww(a*a, b/2);
}

int main(){
	memset(dp, -1, sizeof dp);
	
	cin>>n>>m;
	int p, q;
	for(int i=0;i<m;i++){
		cin>>p>>q;
		d[p][q]=1;d[q][p]=1;
	}
	
	int simplePaths = 0;
	
	for(int mask=0;mask<poww(2, n);mask++){
		for(int i=0;i<n;i++){
			if(__builtin_popcount(mask) == 1 && bit(i, mask) == 1){
				dp[mask][i]=1;		//start and at the vertex i
			}else if(__builtin_popcount(mask) > 1 && bit(i, mask) == 1){
				int tot=0;
				for(int j=0;j<n;j++){
					if(bit(j, mask) == 1 && d[i][j] == 1 && i != j){
						//dp[mask ^ poww(2, i)][j] = tot ham walk of all vertices in mask that end at j
						//which exclude i.
						tot += dp[mask ^ poww(2, i)][j];
					}
				}
				dp[mask][i] = tot;
			}else dp[mask][i] = 0;
			
			//adding simple paths
			if(__builtin_popcount(mask) > 1) simplePaths += dp[mask][i]; 
		}
	}
	simplePaths /= 2;	//because we count every path twice
	cout<<simplePaths<<endl;
return 0;
}
